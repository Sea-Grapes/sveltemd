# layouts issue [#584](https://github.com/pngwn/MDsveX/issues/584)

Currently I implemented nested & filesystem layouts which are quite nice to work with. But these are bad for perf and processing.

The new approach would be to use native sveltekit routing features (groups and layouts) to avoid patching the module script altogether. Instead, we can store frontmatter in a Map/Object containing path and frontmatter. Then we can provide a func to get the data for a page, still in svelte-config land. Then we can provide a 2nd file that exports a state object, which reacts to page.url store changing, and gets data for the current page. Theoretically this should work for SSR as well.

v2: tried the above, but realized filesystem layouts actually are better.

- since they only apply to markdown, they can be put at the root of folders. Say you're creating a documentation site with multiple subroutes, such as /intro, /install, /tutorial, each with markdown pages inside. If you want these to all have the same style, you can put a layout at the root and all will recieve it. With normal layouts you cannot do this, since layouts apply to everything (well you could use an if block to detect if there's frontmatter, but this is poor dx)

v3: returning to native layouts idea

Perhaps we can make layouts conditional by providing a component, such as `<MDLayout>`, which toggles between markdown layout/normal layout (or simply only renders for markdown if the user doesn't need normal layout at that level). This potentially loses some of the clarity of custom layouts, but may be better perf & hackiness-wise

This example has some interesting ideas [docs](https://svelte.dev/docs/svelte/v5-migration-guide#Snippets-instead-of-slots-Passing-data-back-up)

```svelte
<List items={['one', 'two', 'three']} let:item>
	{#snippet item(text)}
		<span>{text}</span>
	{/snippet}
	<span slot="empty">No items yet</span>
	{#snippet empty()}
		<span>No items yet</span>
	{/snippet}
</List>
```

Is `let:item` depricated? I cannot find details in the docs yet. Potentially:

```svelte
// +layout.svelte

<MDLayout let:meta>
</MDLayout>
```

^ Nevermind, it is depricated. use snippets instead.

Attachments also seem to do what we want ([docs](https://svelte.dev/docs/svelte/@attach)):

> Attachments are functions that run in an effect when an element is mounted to the DOM or when state read inside the function updates.
> Optionally, they can return a function that is called before the attachment re-runs, or after the element is later removed from the DOM.

Rather than using a `page()` function for metadata, perhaps we can get it only in the layout component, since that is where it's needed anyway.

option 1:

```svelte
<script>
  import { page, MDLayout, Layout } from 'sveltemd'
</script>

<!-- only renders when current page is md -->
<MDLayout>

</MDLayout>

<!-- only renders when current page is not md -->
<Layout>

</Layout>
```

option 2: the more "correct" version probably, but I doubt people will like this

```svelte
<Layout>
  {#snippet md(data)}
    <h1>Blog post: {data.title}</h1>
    <h2>Published: {data.date}</h2>
    {@render children?.()}
  {/snippet}

  <!-- perhaps there's a different way to default, but I didn't find any info -->
  {#snippet default()}
    <!-- renders when not md page -->
  {/snippet}
</Layout>
```

# Managing html entities

Goals

- html entities should only be allowed in pre/code blocks, and also any the user explicitly writes.
- user written is handled using placeholder (SVELTEMD_i)
- need to call decode() but avoid pre. Probably call decode(), then parse hast, visit

Steps:

1. replace all html entities with placeholder (this will secure ones written manually by user, in both body and script tags)
2. parse markdown - now body may have some entities, and pre/code tags definitely have entities.
3. replace pre/code blocks with placeholders. Now only entities should be in body generated by md parser.
4. call global parseEntities on whole string.
5. replace all placeholders back in.
6. done! probably

How to replace all entities with placeholders?

- store string beforehand
- call parse entities from lib (I will use html-entities since it claims to be fast and has easy api)
- use lib for string diff
- replace diffs with placeholder (store placeholder and value map)

Alternative solution

- replace user-created entities with placeholders.
- parse markdown using any parser - this may create entities
- call global parseEntities - no more entities
- parse to hast/html processor - re-escape (restore entities) in pre/code blocks
- restore user-created entities.

Other ideas

- fork hast-util-to-html and remove text stringify. This may be ok to do as it doesn't seem to do much/isn't very helpful.
- write a rehype plugin to visit all text and swap entities for placeholders. This may suck for perf since it needs string diff and generates a lot of placeholders (every entity in code blocks). Potentially a way to improve this by storing placeholders differently (grouping ones that are the same and storing their indexes?)

# New fragmenting approach

I think the best way to approach mixed svelte/markdown is to just detect markdown regions, then parse/swap them out. (Rather than parsing the whole file as markdown). This is because commonmark markdown in html requires a blank line in front anyway. So potentially we can just do 2 things:

- Any text content in `<element></element>` or `{#logic}{/logic}` will be parsed as markdown if the element spans multiple lines, and if it has a blank line in front. This is commonmark standard.
- For the main body, parse anything not in script/style tag. Somehow ignore the above ^, perhaps by slicing out the content.

Possible approach:

1. Parse frontmatter
2. slice top-level script and style tags. (Store fragments in array, or perhaps in string. I don't think having svelte fragments in misc places (such as before/after script/style) is necessary, but perhaps we can preserve it just for parity)
3. Somehow parse nested element/logic blocks.

## Identifying markdown regions

md regions should be in any of these formats:

```
<element_start>
(blank line)
(mdContent)
<element_end>

<element_start>
(blank line)
(mdContent)
  <element_start_2>

{logic_start}
(blank line)
(mdContent)
{logic_end}

{logic_start}
(blank line)
(mdContent)
  {logic_start}

// etc: lots of combos

<element_start>
(blank line)
(mdContent)
{logic_start}
```

However this is too brittle to just match all these.

## New idea

- I think the best approach now is to call svelte parse first, then parse markdown on text nodes, and maybe unwrap text node <p> if it has no blank lines (double newline).
- First we need to escape things that break svelte. Theoretically this is only:
- any `<` or `{` that doesn't look like `<element>`, `{#logic`
- possibly all `<` and `{` in code/inline code blocks
- It really depends on how svelte parses. (Does it break if `>` and `}` are unescaped?)

Thoughts

- for <, we only need to avoid escaping the front part of `<element`. This one should be pretty simple, since html element can't have < anywhere in it that will break it (It can be in strings and get escaped, that is ok). So this one we can probably just replace any < that is not in the format "<text>" or "</text>" (maybe "<text />" too if necessary). This does mean that if the user just types <text> expecting it to be escaped it won't work, but this is an error raised by svelte anyway so it should be ok. (For more correctness, I could maybe just parse this to a hast, escape any < in text, and restore to string).
- Logic blocks are trickier because their special character is `{`, but they can have `{` inside them (such as in javascript). so we can't just match { to } because it may not be the correct ending. Not sure about this one.
- Code blocks and inline code definitely need all of these to be escaped. < chars in code could be escaped by the hast. `{` ones can't be escaped automatically in the same way, so perhaps we could search for backticks. Not sure about this one.
- Definitely will remove the script/css tags before escaping. Also unsure how to detect these properly.


# "Preprocess" in the preprocessor

I just realized there can be a "preprocess" phase that the user can customize. This runs before svelte-parse, and selectively replaces certain things that would normally break svelte parser.
- Code blocks are processed here and converted to html.
- This can allow the user to do "impossible" things, like having latex directly in markdown.
- Added side-benefits of synchronus svast walking, no custom escaping

# Preprocess before or after (Just escaping or more than that)?

Currently preprocessor runs before everything, but it also handles code blocks. The idea was to parse everything that breaks svelte first (including code blocks). The downside is this requires placeholders (html comments). This could have unintended consequences.
- The alternative solution is to use custom escape sequences, like `+#SVMD0;` perhaps. These would only need to escape invalid `<` and `{` characters, and then escaping preprocess would only be responsible for strictly escaping. Then they could be replaced after (before md parsing). This *may* be good I cannot tell.
- Cons: The obvious downside is that users cannot type that escape sequence anymore, but why would they need to? It also means more placeholders instead of just a few comments. It also means magic-string will have a lot of replace/replaceAll to do (but maybe its intended for this?) The pros are it unifies the md parsing again. This may be very good for custom markdown components though.


1. Process before (code blocks, latex) + escaping
Pros
- Somewhat simpler. We parse with mdast first, then use positional info right away.
- Somewhat easier to understand. Only 1 parsing step. (technically 2 if you count replacing)
Cons
- requires comment placeholders which sometimes break (ex. in block quotes) and require replacement after everything (hacky)
- Cannot be used like other markdown features (ex. cannot be used inline or in literally any text node identified by svelte)

2. Only escape with custom escapes `+#SVMD0;`, process after in markdown
Pros
- same freedom to use markdown as other features - you can have inline code blocks, latex, etc. go crazy with it
- actually maybe not. I just realized the mdast will not detect code blocks that are invalid to escape them.
  - actually perhaps it could be done by calling mdast inside every hast text node. But this may be slow idk.
- probably 100% correct - can have code blocks in blockquotes and every other markdown feature

Cons
- Somewhat harder to understand. requires escaping first, then replacing escapes, so that markdown can use it later. ("3" parsing steps)
- requires custom escape characters, which could be escaped `\+#SVMD0;` but then would require escaping logic for just these local areas. Maybe custom escapes are ok though since you can't write raw html entities in markdown anyway. &\#123; Oh wait you can write raw entities - huh. Not sure how that works. I guess any special symbol for markdown purposes can be escaped, and # is a special symbol for headings. More research necessary.
- requires somewhat complex escaping logic. For example, to escape code blocks, we can either find every index of invalid characters and replace them in magic-string, or we can reserialize the code block as a string, replace it normally, then swap it into the magic string.

3. The golden ideal (impossible I think)
- ideally if we somehow knew exactly where svelte blocks containing `{` were, we could escape every other `{`, thus not needing any custom escaping logic. Unfortunately the only 100% true way to identify logic blocks is with the svelte parser, which we need to escape *before*. We can't use the svelte parser to escape before the svelte parser. Perhaps there is a genius way to solve this but I can't think of any.

## Placeholders

I think comment placeholders have a subtle issue - they are parsed into svast. Therefore markdown will not access them, thus why code in blockquotes fails. Might be better to use custom escape sequence?

Third option: we can keep doing the preprocess thing. However, instead of using node value, use the actual string indexes and slice it. This preserves block quote stuff for example. Basically we can use the entity for the whole block instead of individual characters. This may stress magic-string less and also reduce the number of replaces/entities resulting. Then just restore them before md parse.
- in sum: entities are not just characters, they can also stand for whole sections of the text that need escaping entirely. This moves code block parsing to the actual parser however (not that thats a bad thing)


# New parser idea! (v3?)

Simply: first use strategies (mdast, hast) to escape for svelte parse. Then use svelte parse to escape for markdown! done!
- svelte parse can be used to escape things that break markdown. Logic blocks, value interpolations {}, attributes with js like onclick. We simply have to generate a placeholder that markdown ignores, then restore it after.


# Avoiding placeholders

- content-specific placeholders kind of suck and are hacky
  - For preprocess: perhaps we can fix this with magic strings/indexes? Instead of placeholders, simply cut out content and store the index. Then parse with svast, now we have indexes of document with stuff cut out. Now restore the content, but somehow update the indexes.
  - magic string might actually work here I can't tell. Like 

say we take in a mixed svelte/markdown file. We locate code blocks and illegal < with hast/mdast. We cut those out, store their starting position in the original string. Then svast runs and it gets indexes of all the svelte nodes. Now we want to put back the content. But this makes the svast indexes wrong. But we don't want to update all the svast indexes that would be too slow. So maybe when using the svast and going to specific nodes, we check all the inserted content that comes before its index and add their lengths to the svast index. Actually instead we could use a magic string to insert the cut content. Then we can still access the original string using svast indexes. That works!
- alternatively we could replace illegal content with whitespace of the same length. Theoretically this would be ok as svast will not change content - though it might cause issues, not sure about the safety of this.

- For markdown placeholders - we don't even need magic string! simply cut out strings and store indexes beforehand. then do a string diff, and update each index based on each diff. Now the indexes are correct!


## Diffing/Cutting algorithm

- current version is O(n^2), we can do much better.
- firstly, sort the input values first, ascending order. Then get the first item. iterate the diffs until its the current one. Process it. Check the next, etc. This ver. is probably like O(nlog(n)) (sort) + O(n+m) (myers diff) + O(n) (my iteration).

unrelated - also might be wise to replace {#logic} blocks with actual html substitute (custom element) to benefit from inline markdown. This would need storing start/end index or perhaps start/length. We only have to find where the index goes though, since the length stays the same and can be replaced.

perhaps we should invest in constructing a custom string for markdown. Like basically stringify the svast, but only the bits that are safe. Or perhaps this is too hard to do.

Like we could potentially visit all Text, RegularElement, and SvelteElement nodes, then combine them - eh maybe not idk.

# New plan perhaps?

1. escape raw text
2. parse svast
3. restore escaped
4. Parse each text/html svast node individually, but at the same time. combine svast text/html into a fake markdown doc (markdown only cares about text and html afaik). Either use html comment seperators or store indexes. Also remove any svelte things from html elements.
5. restore each text node into the svelte text. Perhaps a good way to do this is when slicing out html and text nodes, get the other parts that its being sliced out of. Then you can simply add them together as text. Perhaps this could be applied in other places too to avoid diffing/magic-string/indexing.

## Why use this approach (escaping for svete parse) justification

Why should we use this approach rather than the typical approaches, rewriting parsers/creating real ast specs/modding unified?

There's a few good reasons:
- simple to write and maintain
- svelte syntax may change, who knows? Probably not that drastically, but still features may be added, such as `{@attach}`
- svelte logic blocks can be complex, containing typescript or javascript based on internals/project setup stuff I can't access easily. In fact I'm fairly certain mdsvex parses logic blocks incorrectly (though maybe that's being fixed in the next ver., idk)

Downsides
- probably less performant
- feels a bit hacky and uses some hacky things
- probably won't become a "standard" lib, but I'm ok with that
- manual escaping for `{` and `<` *before* svelte-parse. This could be automatic if svelte things were reliably detectable. (As mentioned above, I don't have a good way to do this.)
- probably a ton of others I forgot

Misc note - plugin must become a vite plugin to allow enhanced:img. Also helpful for layouts.

## Other ideas

- Perhaps we could not do string based? Parse the svelte ast, then somehow convert it to a mdast and stringify? probably not worth it since svast can change.


# New idea: follow mdsx

Mdsx seems to work well since its from svecosystem. What other features would I provide in addition to them?
- file based layouts - not sure if this is good or not.
- more correct logic/html matching?
- access frontmatter anywhere

# Reasons to make a it a vite plugin

- can glob layouts proplery
- avoid using import.meta.glob to get markdown frontmatter, which every other md processor lib does. This **reparses** your files. this is bad for perf. Some other ssgs and such do a custom solution like this.

# Comparing MDSX

Unfortunately the mdsx approach is not the 100% bulletproof solution I was hoping it could be, for example this fails:
```svelte
{#if true}

This is **a** test
{/if}
```

This is because **a** is treated as markdown in the second paragraph, so the second paragraph has 3 children: a text node, a bold node, and a text node. Therefore the {/if} is not the first child and won't get properly unwrapped.
Additionally, the MDSX solution simply converts any non text/html nodes to plain text like `**plain**`. You will not get markdown highlighting inside these areas. This is because markdown only has a few node types, notably paragraph/html. Html will pass through everything as raw text, and paragraph will wrap in a p and cause the children to be parsed. There is no node (afaik) that does the same as paragraph without wrapping in an element.
This could be remedied by introducing a new node type (I believe what mdx does) that does the above.


# Simplicity

Perhaps there is a way to just write small parsers that target svelte things, and either make them compatable with markdown, or heal the resulting output. The main issues are:
- invalid html will get escaped
- things may get wrapped incorrectly in p

Possible approach: micromark customization, like mdx

For logic blocks:
- do a simple regex to match {# or {@A-Z or whatever the simple format is
- Use svelte's util for bracket matching that takes into account js strings, etc.
- Now we know where the logic block ends, so store this and continue parsing markdown normally
- Probably also handle closing and such

# CONCLUSION

For long term stability and low-maintenance, the best approach is to rely on Svelte's parse function and escape beforehand.
- Ultimately this can be viewed as: official svelte parser + official markdown parser + coordination layer

Reasoning:
- we don't know if svelte's syntax will change. New features may be added.
- custom parsing is brittle and requires maintenance, and I am not skilled at parsing professionally.
- most other md parsers in the past have edge cases and bugs.

Once svelte becomes more stable (Can software ever be stable?) then a new parser could be written that understands both.
- Alternatively, people can use MDsveX v2 or Mdsx if/when they come to fruition.

# Actually

Erm actually screw that im gonna make a micromark extension and copy mdx and it'll be great trust

New plan:
- theoretically, all we have to do is detect logic and supercharged-svelte-html properly, then put it in a seperate html mdast node. This will get remark-rehype'd into a raw node, and it will be all fine and dandy.

Example of mdast:
```js
[
  {
    type: "html", value: "{#if true}"
  },
  {
    type: "paragraph", children: ...
  },
  {
    type: "html", value: "{:else}"
  }
  ... etc
]

```

This is easier than adding a new node type and modding things to work with it. Proper ast may be added in the future (but is it worth it to mod stringify and such?)

# Another idea

Perhaps we can parse an mdast first, collect the text (and html? or maybe not) from that, pass those through svast with delimiters, stringify the other mdast nodes that aren't text, and combine them just based on interleaving order.