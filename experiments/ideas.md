# layouts issue [#584](https://github.com/pngwn/MDsveX/issues/584)

Currently I implemented nested & filesystem layouts which are quite nice to work with. But these are bad for perf and processing.

The new approach would be to use native sveltekit routing features (groups and layouts) to avoid patching the module script altogether. Instead, we can store frontmatter in a Map/Object containing path and frontmatter. Then we can provide a func to get the data for a page, still in svelte-config land. Then we can provide a 2nd file that exports a state object, which reacts to page.url store changing, and gets data for the current page. Theoretically this should work for SSR as well.

v2: tried the above, but realized filesystem layouts actually are better.

- since they only apply to markdown, they can be put at the root of folders. Say you're creating a documentation site with multiple subroutes, such as /intro, /install, /tutorial, each with markdown pages inside. If you want these to all have the same style, you can put a layout at the root and all will recieve it. With normal layouts you cannot do this, since layouts apply to everything (well you could use an if block to detect if there's frontmatter, but this is poor dx)

v3: returning to native layouts idea

Perhaps we can make layouts conditional by providing a component, such as `<MDLayout>`, which toggles between markdown layout/normal layout (or simply only renders for markdown if the user doesn't need normal layout at that level). This potentially loses some of the clarity of custom layouts, but may be better perf & hackiness-wise

This example has some interesting ideas [docs](https://svelte.dev/docs/svelte/v5-migration-guide#Snippets-instead-of-slots-Passing-data-back-up)

```svelte
<List items={['one', 'two', 'three']} let:item>
	{#snippet item(text)}
		<span>{text}</span>
	{/snippet}
	<span slot="empty">No items yet</span>
	{#snippet empty()}
		<span>No items yet</span>
	{/snippet}
</List>
```

Is `let:item` depricated? I cannot find details in the docs yet. Potentially:

```svelte
// +layout.svelte

<MDLayout let:meta>
</MDLayout>
```

^ Nevermind, it is depricated. use snippets instead.

Attachments also seem to do what we want ([docs](https://svelte.dev/docs/svelte/@attach)):

> Attachments are functions that run in an effect when an element is mounted to the DOM or when state read inside the function updates.
> Optionally, they can return a function that is called before the attachment re-runs, or after the element is later removed from the DOM.

Rather than using a `page()` function for metadata, perhaps we can get it only in the layout component, since that is where it's needed anyway.

option 1:

```svelte
<script>
  import { page, MDLayout, Layout } from 'sveltemd'
</script>

<!-- only renders when current page is md -->
<MDLayout>

</MDLayout>

<!-- only renders when current page is not md -->
<Layout>

</Layout>
```

option 2: the more "correct" version probably, but I doubt people will like this

```svelte
<Layout>
  {#snippet md(data)}
    <h1>Blog post: {data.title}</h1>
    <h2>Published: {data.date}</h2>
    {@render children?.()}
  {/snippet}

  <!-- perhaps there's a different way to default, but I didn't find any info -->
  {#snippet default()}
    <!-- renders when not md page -->
  {/snippet}
</Layout>
```

# Managing html entities

Goals

- html entities should only be allowed in pre/code blocks, and also any the user explicitly writes.
- user written is handled using placeholder (SVELTEMD_i)
- need to call decode() but avoid pre. Probably call decode(), then parse hast, visit

Steps:

1. replace all html entities with placeholder (this will secure ones written manually by user, in both body and script tags)
2. parse markdown - now body may have some entities, and pre/code tags definitely have entities.
3. replace pre/code blocks with placeholders. Now only entities should be in body generated by md parser.
4. call global parseEntities on whole string.
5. replace all placeholders back in.
6. done! probably

How to replace all entities with placeholders?

- store string beforehand
- call parse entities from lib (I will use html-entities since it claims to be fast and has easy api)
- use lib for string diff
- replace diffs with placeholder (store placeholder and value map)

Alternative solution

- replace user-created entities with placeholders.
- parse markdown using any parser - this may create entities
- call global parseEntities - no more entities
- parse to hast/html processor - re-escape (restore entities) in pre/code blocks
- restore user-created entities.

Other ideas

- fork hast-util-to-html and remove text stringify. This may be ok to do as it doesn't seem to do much/isn't very helpful.
- write a rehype plugin to visit all text and swap entities for placeholders. This may suck for perf since it needs string diff and generates a lot of placeholders (every entity in code blocks). Potentially a way to improve this by storing placeholders differently (grouping ones that are the same and storing their indexes?)

# New fragmenting approach

I think the best way to approach mixed svelte/markdown is to just detect markdown regions, then parse/swap them out. (Rather than parsing the whole file as markdown). This is because commonmark markdown in html requires a blank line in front anyway. So potentially we can just do 2 things:

- Any text content in `<element></element>` or `{#logic}{/logic}` will be parsed as markdown if the element spans multiple lines, and if it has a blank line in front. This is commonmark standard.
- For the main body, parse anything not in script/style tag. Somehow ignore the above ^, perhaps by slicing out the content.

Possible approach:

1. Parse frontmatter
2. slice top-level script and style tags. (Store fragments in array, or perhaps in string. I don't think having svelte fragments in misc places (such as before/after script/style) is necessary, but perhaps we can preserve it just for parity)
3. Somehow parse nested element/logic blocks.

## Identifying markdown regions

md regions should be in any of these formats:

```
<element_start>
(blank line)
(mdContent)
<element_end>

<element_start>
(blank line)
(mdContent)
  <element_start_2>

{logic_start}
(blank line)
(mdContent)
{logic_end}

{logic_start}
(blank line)
(mdContent)
  {logic_start}

// etc: lots of combos

<element_start>
(blank line)
(mdContent)
{logic_start}
```

However this is too brittle to just match all these.

## New idea

- I think the best approach now is to call svelte parse first, then parse markdown on text nodes, and maybe unwrap text node <p> if it has no blank lines (double newline).
- First we need to escape things that break svelte. Theoretically this is only:
- any `<` or `{` that doesn't look like `<element>`, `{#logic`
- possibly all `<` and `{` in code/inline code blocks
- It really depends on how svelte parses. (Does it break if `>` and `}` are unescaped?)

Thoughts

- for <, we only need to avoid escaping the front part of `<element`. This one should be pretty simple, since html element can't have < anywhere in it that will break it (It can be in strings and get escaped, that is ok). So this one we can probably just replace any < that is not in the format "<text>" or "</text>" (maybe "<text />" too if necessary). This does mean that if the user just types <text> expecting it to be escaped it won't work, but this is an error raised by svelte anyway so it should be ok. (For more correctness, I could maybe just parse this to a hast, escape any < in text, and restore to string).
- Logic blocks are trickier because their special character is `{`, but they can have `{` inside them (such as in javascript). so we can't just match { to } because it may not be the correct ending. Not sure about this one.
- Code blocks and inline code definitely need all of these to be escaped. < chars in code could be escaped by the hast. `{` ones can't be escaped automatically in the same way, so perhaps we could search for backticks. Not sure about this one.
- Definitely will remove the script/css tags before escaping. Also unsure how to detect these properly.


# "Preprocess" in the preprocessor

I just realized there can be a "preprocess" phase that the user can customize. This runs before svelte-parse, and selectively replaces certain things that would normally break svelte parser.
- Code blocks are processed here and converted to html.
- This can allow the user to do "impossible" things, like having latex directly in markdown.
- Added side-benefits of synchronus svast walking, no custom escaping

# Preprocess before or after (Just escaping or more than that)?

Currently preprocessor runs before everything, but it also handles code blocks. The idea was to parse everything that breaks svelte first (including code blocks). The downside is this requires placeholders (html comments). This could have unintended consequences.
- The alternative solution is to use custom escape sequences, like `+#SVMD0;` perhaps. These would only need to escape invalid `<` and `{` characters, and then escaping preprocess would only be responsible for strictly escaping. Then they could be replaced after (before md parsing). This *may* be good I cannot tell.
- Cons: The obvious downside is that users cannot type that escape sequence anymore, but why would they need to? It also means more placeholders instead of just a few comments. It also means magic-string will have a lot of replace/replaceAll to do (but maybe its intended for this?) The pros are it unifies the md parsing again. This may be very good for custom markdown components though.


1. Process before (code blocks, latex) + escaping
Pros
- Somewhat simpler. We parse with mdast first, then use positional info right away.
- Somewhat easier to understand. Only 1 parsing step. (technically 2 if you count replacing)
Cons
- requires comment placeholders which sometimes break (ex. in block quotes) and require replacement after everything (hacky)
- Cannot be used like other markdown features (ex. cannot be used inline or in literally any text node identified by svelte)

2. Only escape with custom escapes `+#SVMD0;`, process after in markdown
Pros
- same freedom to use markdown as other features - you can have inline code blocks, latex, etc. go crazy with it
- actually maybe not. I just realized the mdast will not detect code blocks that are invalid to escape them.
  - actually perhaps it could be done by calling mdast inside every hast text node. But this may be slow idk.
- probably 100% correct - can have code blocks in blockquotes and every other markdown feature

Cons
- Somewhat harder to understand. requires escaping first, then replacing escapes, so that markdown can use it later. ("3" parsing steps)
- requires custom escape characters, which could be escaped `\+#SVMD0;` but then would require escaping logic for just these local areas. Maybe custom escapes are ok though since you can't write raw html entities in markdown anyway. &\#123; Oh wait you can write raw entities - huh. Not sure how that works. I guess any special symbol for markdown purposes can be escaped, and # is a special symbol for headings. More research necessary.
- requires somewhat complex escaping logic. For example, to escape code blocks, we can either find every index of invalid characters and replace them in magic-string, or we can reserialize the code block as a string, replace it normally, then swap it into the magic string.

3. The golden ideal (impossible I think)
- ideally if we somehow knew exactly where svelte blocks containing `{` were, we could escape every other `{`, thus not needing any custom escaping logic. Unfortunately the only 100% true way to identify logic blocks is with the svelte parser, which we need to escape *before*. We can't use the svelte parser to escape before the svelte parser. Perhaps there is a genius way to solve this but I can't think of any.

## Placeholders

I think comment placeholders have a subtle issue - they are parsed into svast. Therefore markdown will not access them, thus why code in blockquotes fails. Might be better to use custom escape sequence?

Third option: we can keep doing the preprocess thing. However, instead of using node value, use the actual string indexes and slice it. This preserves block quote stuff for example. Basically we can use the entity for the whole block instead of individual characters. This may stress magic-string less and also reduce the number of replaces/entities resulting. Then just restore them before md parse.
- in sum: entities are not just characters, they can also stand for whole sections of the text that need escaping entirely. This moves code block parsing to the actual parser however (not that thats a bad thing)


# New parser idea! (v3?)

Simply: first use strategies (mdast, hast) to escape for svelte parse. Then use svelte parse to escape for markdown! done!
- svelte parse can be used to escape things that break markdown. Logic blocks, value interpolations {}, attributes with js like onclick. We simply have to generate a placeholder that markdown ignores, then restore it after.